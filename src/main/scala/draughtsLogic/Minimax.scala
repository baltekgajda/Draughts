package draughtsLogic

import scala.annotation.tailrec
import scala.math.{max, min}
import scala.util.Random

/**
  * Class for minimax algorithm used to control the other player
  *
  * @param boardMatrix two dimensional array holding current board state
  * @param maxDepth    maximum depth of a tree generated by minimax algorithm
  */
case class Minimax(boardMatrix: Array[Array[Int]], maxDepth: Int) {

  /**
    * Finds optimal move sequence for the oponent found by minimax algorithm
    *
    * @return oponent's piece move sequence or empty list
    *         when there are no pieces remaining or player is blocked
    */
  def getOponentMoveSequence: List[Coord] = {
    if (!Board.isGameOver(boardMatrix)) {
      val movesToChooseFrom = Board.getBoardMoves(boardMatrix, true)
      if (movesToChooseFrom.isEmpty)
        List()
      else
        Random.shuffle(movesToChooseFrom).map(l => {
          val newBoard = Board.copyBoard(boardMatrix)
          Board.updateBoard(newBoard, l)
          (l, minimaxAlphaBeta(newBoard, false, maxDepth - 1, Int.MinValue, Int.MaxValue))
        }).maxBy(_._2)._1
    }
    else
      List()
  }

  //TODO isOponent na typ gracza
  /**
    * Performs minimax algorithm
    *
    * @param board     game board on which algorithm operate
    * @param isOponent if true method will consider oponent's possible moves,
    *                  player's otherwise
    * @param depth     current depth of the tree
    * @param alpha     parameter used in alpha-beta pruning
    * @param beta      parameter used in alpha-beta pruning
    * @return depending on isOponent parameter returns maximal or minimal
    *         heuristic value of a subtree
    */
  private def minimaxAlphaBeta(board: Array[Array[Int]], isOponent: Boolean, depth: Int, alpha: Int, beta: Int): Int = {

    /**
      * For given moves, method makes them (updates board and calls minimaxAlphaBeta method)
      * if there is no alpha-beta pruning and returns evaluated maximum heuristic value
      * for a subtree (maximising moves)
      *
      * @param list    list of move sequences that can be made on the current board
      * @param a       alpha parameter
      * @param b       beta parameter
      * @param maxEval current maximal heuristic value for a tree
      * @return heuristic value for a subtree
      */
    @tailrec
    def visitMaxMove(list: List[List[Coord]], a: Int, b: Int, maxEval: Int): Int = {
      if (list.isEmpty || b <= a)
        maxEval
      else {
        val newBoard = Board.copyBoard(board)
        Board.updateBoard(newBoard, list.head)
        val eval = minimaxAlphaBeta(newBoard, !isOponent, depth - 1, a, b)
        visitMaxMove(list.tail, max(a, eval), b, max(maxEval, eval))
      }
    }

    /**
      * For given moves, method makes them (updates board and calls minimaxAlphaBeta method)
      * if there is no alpha-beta pruning and returns evaluated minimum heuristic value
      * for a subtree (minimizing moves)
      *
      * @param list    list of move sequences that can be made on the current board
      * @param a       alpha parameter
      * @param b       beta parameter
      * @param minEval current minimal heuristic value for a tree
      * @return heuristic value for a subtree
      */
    @tailrec
    def visitMinMove(list: List[List[Coord]], a: Int, b: Int, minEval: Int): Int = {
      if (list.isEmpty || b <= a)
        minEval
      else {
        val newBoard = Board.copyBoard(board)
        Board.updateBoard(newBoard, list.head)
        val eval = minimaxAlphaBeta(newBoard, !isOponent, depth - 1, a, b)
        visitMinMove(list.tail, a, min(b, eval), min(minEval, eval))
      }
    }

    if (depth == 0 || Board.isGameOver(board))
      calcHeuristicValue(board)
    else {
      val possibleMoves = Board.getBoardMoves(board, isOponent)
      if (isOponent)
        visitMaxMove(possibleMoves, alpha, beta, Int.MinValue)
      else
        visitMinMove(possibleMoves, alpha, beta, Int.MaxValue)
    }
  }

  /**
    * Calculates the heuristic value for a board. Its a difference between
    * number of oponent's and player's pieces on board
    *
    * @param board game board for which method will calculate the heuristic value
    * @return heuristic value calculated for a game board
    */
  private def calcHeuristicValue(board: Array[Array[Int]]): Int = {
    Board.getPiecesCount(board, true) - Board.getPiecesCount(board, false)
  }
}
